package GameLogic;

import java.awt.Graphics;
import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

import applicationWindow.ClientLogic;
import applicationWindow.RenderPanel;
import applicationWindow.RenderPanel.Direction;
/**
 * Stores a room for the spooky house game
 * @author thomasalex2
 *
 */
public class Room {
	private WorldObject[][] grid;
	private String name;
	private int height;
	private int length;
	public static int TILELENGTH = 20;
	public static int TILEHEIGHT = 20;
	/**
	 * creates a new room object with the given height and length
	 * @param name
	 * @param height
	 * @param length
	 * @param server
	 */
	public Room(String name, int height, int length, boolean server) {
		this.name = name;
		this.height = height;
		this.length = length;
		grid = new WorldObject[length][height];

	}
	/**
	 * Places a player in a new room once they have gone through a door. If successful the player will have
	 * been placed in the new room at a position in front of or close to the door. This method takes into account
	 * that there might be another player in front of the door and will therefore recursively move the player
	 * perpendicular from the door until it finds a coordinate that is free.
	 * Assumes that the given coordinates are within the bounds of the rooms grid array
	 * throws an Illegal Argument exception if the given player is null
	 * @param w
	 * @param gridX
	 * @param gridY
	 * @return true if the player is successfully added to the room
	 * never returns false :S
	 */
	public boolean placeInNewRoom(WorldObject w, int gridX, int gridY) {
		if (w == null) {
			throw new IllegalArgumentException();
		}
		if (gridX == 0) {
			gridX = 1;
			if (grid[gridX][gridY] != null) {
				return placeInNewRoom(w,gridX + 1,gridY);
			}
		} else if (gridY == 0) {
			gridY = 1;
			if (grid[gridX][gridY] != null) {
				return placeInNewRoom(w,gridX,gridY+1);
			}
		} else if (gridX == length - 1) {
			gridX = length - 2;
			if (grid[gridX][gridY] != null) {
				return placeInNewRoom(w,gridX-1,gridY);
			}
		} else if (gridY == height - 1) {
			gridY = height - 2;
			if (grid[gridX][gridY] != null) {
				return placeInNewRoom(w,gridX,gridY-1);
			}
		}
		grid[gridX][gridY] = w;
		return true;
	}
	/**
	 * Attempts to remove a player from the room as they are going through a door. If successful this method
	 * will remove the player from the room.
	 * Assumes that the given coordinates are within the bounds of the rooms grid array
	 * Assumes that the player is in range of the door
	 * throws an Illegal Argument exception if the given player is null
	 * @param player
	 * @param playerX
	 * @param playerY
	 * @param doorX
	 * @param doorY
	 * @return true if the player is successfully removed from the room
	 * return false if the object at either the door or player coordinates is null
	 * returns false if the object at the playerCoordinates is not a player
	 * returns false if the object at the door coordinates is not a door
	 */
	public boolean goThroughDoor(HumanPlayer player, int playerX, int playerY, int doorX, int doorY) {
		if (player == null) {
			throw new IllegalArgumentException();
		}
		if (grid[doorX][doorY] == null || grid[playerX][playerY] == null) {
			return false;
		}
		if (!(grid[playerX][playerY] instanceof HumanPlayer)) {
			return false;
		}
		if (!(grid[doorX][doorY] instanceof Door)) {
			return false;
		}
		Door door = (Door) grid[doorX][doorY];
		if (door.isLocked()) {
			return false;
		}
		removeObject(player, playerX, playerY);
		return true;
	}
	/**
	 * Attempts to either lock or unlock a door at the given door index. If Successful this method will
	 * lock the door if the door was unlocked or unlock the door if it was locked.
	 * Assumes the given coordinates are within the bounds of the grid array
	 * Assumes that the player is in range of the door
	 * throws an Illegal argumentException if the given player is null
	 * @param p
	 * @param playerX
	 * @param playerY
	 * @param doorX
	 * @param doorY
	 * @param keyName
	 * @return true if the door was successfully unlocked/locked
	 * returns false if the object at the door coordinates or the player coordinates = false
	 * returns false if the object at the playerCoordinates is not a player
	 * returns false if the object at the door coordinates is not a door
	 * returns false if the door was not successfully locked/unlocked
	 */
	public boolean lockOrUnlockDoor(HumanPlayer p, int playerX, int playerY, int doorX, int doorY, String keyName) {

		if (p == null) {
			throw new IllegalArgumentException();
		}
		if (grid[doorX][doorY] == null || grid[playerX][playerY] == null) {
			return false;
		}
		if (!(grid[playerX][playerY] instanceof HumanPlayer)) {
			return false;
		}
		if (!(grid[doorX][doorY] instanceof Door)) {
			return false;
		}
		Door door = (Door) grid[doorX][doorY];
		if (door.isLocked()) {
			return door.unlock(keyName);
		} else {
			return door.lock(keyName);
		}
	}
	/**
	 * Attempts to place an item from the players inventory at a given index. If successful this method
	 * will remove the item from the given player and will place it at the given place index's.
	 * Assumes that the player is within reach of the place where he is placing the item.
	 * Assumes the given coordinates are within the bounds of the grid array
	 * Assumes that the player has an item at the item index
	 * throws an Illegal argumentException if the given player is null
	 * @param p
	 * @param playerX
	 * @param playerY
	 * @param placeX
	 * @param placeY
	 * @param itemIndex
	 * @return true if the item is successfully placed in the room and removed from the players inventory
	 * returns false if the object at the place index's is not null
	 * returns false if the object at the player coordinates is null
	 * returns false if the object at the player coordinates is not a player
	 */
	public boolean placeItem(HumanPlayer p, int playerX, int playerY, int placeX, int placeY, int itemIndex) {
		if (p == null) {
			throw new IllegalArgumentException();
		}
		if (grid[placeX][placeY] != null || grid[playerX][playerY] == null) {
			return false;
		}
		if (!(grid[playerX][playerY] instanceof HumanPlayer)) {
			return false;
		}
		grid[placeX][placeY] = p.removeItemAt(itemIndex);
		return true;
	}
	/**
	 * Attempts to make the given player at the playerX and playerY to pickup the item at itemX itemY
	 * assumes that the player is close enough to pickup the item also assumes the given coordinates are
	 * within the boundary
	 * if successful this method removes the item from the room and adds it to the players inventory
	 * throws an IllegalArgumentException if the given player is null
	 * @param p
	 * @param playerX
	 * @param playerY
	 * @param itemX
	 * @param itemY
	 * @return true if the item is successfully removed from the room and added to the players inventory
	 * returns false if the object at the playerCoordinates or item coordinates is null
	 * returns false if the object at the item coordinates is not an item
	 * returns false if the object at the player coordinates is not a player
	 *
	 */
	public boolean pickupItem(HumanPlayer p, int playerX, int playerY, int itemX, int itemY) {
		if (p == null) {
			throw new IllegalArgumentException();
		}
		if (grid[itemX][itemY] == null || grid[playerX][playerY] == null) {
			return false;
		}
		if (!(grid[itemX][itemY] instanceof Item) || !(grid[playerX][playerY] instanceof HumanPlayer)) {
			return false;
		}
		Item e = (Item) grid[itemX][itemY];
		p.addItem(e);
		grid[itemX][itemY] = null;
		return true;
	}

	/**
	 * Attempts to Move a given object from one coordinate to the next. If successful the Object is moved from
	 * the old coordinates in the grid to the new coordinates in the grid
	 * Assumes the given coordinates are within the bounds of the grid array
	 * Assumes that the given object is allowed to move to the new position
	 * throws an Illegal argument exception if the object is null
	 * @param object
	 * @param oldX
	 * @param oldY
	 * @param newX
	 * @param newY
	 * @return true if the object is successfully moved
	 * false if the object at the old grid point does not match the object being moved and
	 * also if there is already an object at the new position
	 */
	public boolean moveObject(WorldObject object, int oldX, int oldY, int newX, int newY) {
		if (object == null) {
			throw new IllegalArgumentException();
		}
		if (grid[newX][newY] != null || grid[oldX][oldY] == null || !grid[oldX][oldY].equals(object)) {
			return false;
		} else {
			grid[newX][newY] = object;
			grid[oldX][oldY] = null;
			return true;
		}
	}

	/**
	 * checks if a player move is able to move from the old coordinates to the new coordinates
	 * only checking that the move isn't too far away and also if the new position isn't on the sides of the
	 * room unless it is a door.
	 * Also checks that the given coordinates are within the bounds of the room
	 *
	 * @param oldX
	 * @param oldY
	 * @param newX
	 * @param newY
	 * @return true if the new position is 1 square from the old position
	 * and if the new position is not on a wall
	 * returns false if the newCoordinates are more than 1 tile away from the old coordinates
	 * returns false if the newCoordinates are on the side of the room unless it is a door
	 */
	public boolean canMove(int oldX, int oldY, int newX, int newY) {
		if (outOfXBounds(oldX) || outOfXBounds(newX) || outOfYBounds(oldY) || outOfYBounds(newY)) {
			return false;
		}
		WorldObject objectAtNewPos = objectAt(newX,newY);

		if(newX == 0 || newX == length-1 || newY == 0 || newY == height-1){
			if(objectAtNewPos == null){
				if(objectAtNewPos == null || !(objectAtNewPos instanceof Door)){
					return false;
				}
			}
			return Math.abs((oldX - newX) + (oldY- newY))==1;
		}
		return Math.abs((oldX - newX) + (oldY- newY))==1;
	}

	/**
	 * removes the object from the room and only the room
	 * throws an IllegalArgumentException if the object is null
	 *
	 * @param object
	 * @param xPos
	 * @param yPos
	 * @return true if the object is removed false if the object is not at the given position and is therefore not removed
	 */
	public boolean removeObject(WorldObject object, int xPos, int yPos) {
		if (object == null) {
			throw new IllegalArgumentException();
		}
		if (grid[xPos][yPos] == null || !grid[xPos][yPos].equals(object)) {
			return false;
		}
		grid[xPos][yPos] = null;
		return true;
	}

	/**
	 * finds the position of the object in the room grid
	 * throws an IllegalArgumentException if the object is null returns null if it cannot find the object
	 *
	 * @param object
	 * @return A point of where the object is on the rooms grid
	 *
	 */
	public Point positionOfObject(WorldObject object) {
		if (object == null) {
			throw new IllegalArgumentException();
		}
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < length; x++) {
				if (object.equals(grid[x][y])) {
					return new Point(x, y);
				}
			}
		}
		return null;
	}

	/**
	 * adds a worldObject to a specified position ensuring that no other objects are already at that position
	 * throws a IllegalArgumentException if the given object is null
	 *
	 * @param w
	 * @param gridX
	 * @param gridY
	 * @return true if the object is added false if it is not
	 */
	public boolean addObject(WorldObject w, int gridX, int gridY) {
		if (w == null) {
			throw new IllegalArgumentException();
		}
		if (grid[gridX][gridY] != null) {
			return false;
		}
		grid[gridX][gridY] = w;
		return true;
	}

	/**
	 * adds a character to a random position in the room ensuring that no other objects are already there
	 *
	 * @param c
	 */
	public void addCharacter(Character c) {
		Random r = new Random();
		int x = r.nextInt(length - 2) + 1;
		int y = r.nextInt(height - 2) + 1;
		while (grid[x][y] != null) {
			x = r.nextInt(length - 2) + 1;
			y = r.nextInt(height - 2) + 1;
		}
		grid[x][y] = c;
	}
	/**
	 * returns the object on the grid at the given x and y coordinates
	 * @param x
	 * @param y
	 * @return
	 */
	public WorldObject objectAt(int x, int y) {
		if (x < 0 || x >= length || y < 0 || y >= height) {
			return null;
		}
		return grid[x][y];
	}
	/**
	 * draws the room and all the objects in the room based on the current viewing direction
	 * @param g
	 * @param d
	 */
	public void draw(Graphics g, RenderPanel.Direction d) {
		if (d.equals(RenderPanel.Direction.EAST)) {
			for (int y = 0; y < length; y++) {
				for (int x = 0; x < height; x++) {
					int rotatedX = getRotatedX(d, y);
					int rotatedY = getRotatedY(d, x);
					g.drawImage(ClientLogic.floorImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT, null);
					if (y == 0) {
						g.drawImage(ClientLogic.backWallImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT, null);
					}
					if (x == 0) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						g.drawImage(ClientLogic.wallSideImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH - 10, Room.TILEHEIGHT, null);
					}
					if (x == height - 1) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						g.drawImage(ClientLogic.wallSideImage, x * Room.TILELENGTH + 10, y * Room.TILEHEIGHT, Room.TILELENGTH - 10, Room.TILEHEIGHT, null);
					}
					if (y == length - 1) {
						g.drawImage(ClientLogic.backWallImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT-10, Room.TILELENGTH, Room.TILEHEIGHT+10, null);
					}
					if (grid[rotatedX][rotatedY] == null) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
					} else {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						grid[rotatedX][rotatedY].draw(g, d, x * Room.TILELENGTH, y * Room.TILEHEIGHT);
					}
				}
			}
		} else if (d.equals(RenderPanel.Direction.WEST)) {
			for (int y = 0; y < length; y++) {
				for (int x = 0; x < height; x++) {
					int rotatedX = getRotatedX(d, y);
					int rotatedY = getRotatedY(d, x);
					g.drawImage(ClientLogic.floorImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT, null);
					if (y == 0) {
						g.drawImage(ClientLogic.backWallImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT, null);
					}
					if (x == 0) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						g.drawImage(ClientLogic.wallSideImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH - 10, Room.TILEHEIGHT, null);
					}
					if (x == height - 1) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						g.drawImage(ClientLogic.wallSideImage, x * Room.TILELENGTH + 10, y * Room.TILEHEIGHT, Room.TILELENGTH - 10, Room.TILEHEIGHT, null);
					}
					if (y == length - 1) {
						g.drawImage(ClientLogic.backWallImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT-10, Room.TILELENGTH, Room.TILEHEIGHT+10, null);
					}
					if (grid[rotatedX][rotatedY] == null) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
					} else {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						grid[rotatedX][rotatedY].draw(g, d, x * Room.TILELENGTH, y * Room.TILEHEIGHT);
					}
				}
			}
		} else if (d.equals(RenderPanel.Direction.SOUTH)) {
			for (int y = 0; y < height; y++) {
				for (int x = 0; x < length; x++) {
					int rotatedX = getRotatedX(d, x);
					int rotatedY = getRotatedY(d, y);
					g.drawImage(ClientLogic.floorImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT, null);
					if (y == 0) {
						g.drawImage(ClientLogic.backWallImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT, null);
					}
					if (x == 0) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						g.drawImage(ClientLogic.wallSideImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH - 10, Room.TILEHEIGHT, null);
					}
					if (x == length - 1) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						g.drawImage(ClientLogic.wallSideImage, x * Room.TILELENGTH + 10, y * Room.TILEHEIGHT, Room.TILELENGTH - 10, Room.TILEHEIGHT, null);
					}
					if (y == height - 1) {
						g.drawImage(ClientLogic.backWallImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT-10, Room.TILELENGTH, Room.TILEHEIGHT+10, null);
					}
					if (grid[rotatedX][rotatedY] == null) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
					} else {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						grid[rotatedX][rotatedY].draw(g, d, x * Room.TILELENGTH, y * Room.TILEHEIGHT);
					}
				}
			}
		} else if (d.equals(RenderPanel.Direction.NORTH)) {
			for (int y = 0; y < height; y++) {
				for (int x = 0; x < length; x++) {
					g.drawImage(ClientLogic.floorImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT, null);
					if (y == 0) {
						g.drawImage(ClientLogic.backWallImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT, null);
					}
					if (x == 0) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						g.drawImage(ClientLogic.wallSideImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH - 10, Room.TILEHEIGHT, null);
					}
					if (x == length - 1) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						g.drawImage(ClientLogic.wallSideImage, x * Room.TILELENGTH + 10, y * Room.TILEHEIGHT, Room.TILELENGTH - 10, Room.TILEHEIGHT, null);
					}
					if (y == height - 1) {
						g.drawImage(ClientLogic.backWallImage, x * Room.TILELENGTH, y * Room.TILEHEIGHT-10, Room.TILELENGTH, Room.TILEHEIGHT+10, null);
					}
					if (grid[x][y] == null) {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
					} else {
						g.drawRect(x * Room.TILELENGTH, y * Room.TILEHEIGHT, Room.TILELENGTH, Room.TILEHEIGHT);
						grid[x][y].draw(g, d, x * Room.TILELENGTH, y * Room.TILEHEIGHT);
					}
				}
			}
		}
	}
	/**
	 * returns the rotated X coordinate based on the viewing direction
	 * @param view
	 * @param x
	 * @return
	 */
	public int getRotatedX(Direction view, int x) {
		if (view == Direction.NORTH) {
			return x;
		} else if (view == Direction.SOUTH) {
			return x + length - x * 2 - 1;
		} else if (view == Direction.EAST) {
			return x + length - x * 2 - 1;
		} else {
			return x;
		}
	}
	/**
	 * returns the rotated Y coordinate based on the viewing direction
	 * @param view
	 * @param y
	 * @return
	 */
	public int getRotatedY(Direction view, int y) {
		if (view == Direction.NORTH) {
			return y;
		} else if (view == Direction.SOUTH) {
			return y + height - y * 2 - 1;
		} else if (view == Direction.EAST) {
			return y;
		} else {
			return y + height - y * 2 - 1;
		}
	}

	// //////////////////////////getters/Setters/minor helper methods go here\\\\\\\\\\\\\\\\\\\\\\\\\\
	/**
	 * returns true if the given value is greater than the length of the room or less than 0
	 *
	 * @param xValue
	 * @return
	 */
	public boolean outOfXBounds(int xValue) {
		return xValue < 0 || xValue >= length;
	}

	/**
	 * returns true if the given value is greater than the height of the room or less than 0
	 *
	 * @param yValue
	 * @return
	 */

	public boolean outOfYBounds(int yValue) {
		return yValue < 0 || yValue >= height;
	}
	/**
	 * returns the name of the room
	 * @return
	 */
	public String getName() {
		return name;
	}
	/**
	 * returns a representation of this room and all the objects inside it as a string
	 */
	public String toString() {
		String roomString = name + " " + height + " " + length;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < length; x++) {
				if (grid[x][y] != null) {
					roomString = roomString + " O " + x + " " + y + " " + grid[x][y].toString();
				}
			}
		}
		return roomString;
	}
	/**
	 * loads a the objects in a room from a string based on the toString method above
	 * @param s
	 */
	public void loadFromScanner(Scanner s) {
		while (s.hasNext("O")) {
			s.next();
			int objectX = s.nextInt();
			int objectY = s.nextInt();
			String objType = s.next();
			WorldObject object = null;
			switch (objType) {
			case "HP":
				object = HumanPlayer.loadFromScanner(s);
				break;
			case "FU":
				object = Furniture.loadFromScanner(s);
				break;
			case "KEY":
				object = Key.loadFromScanner(s);
				break;
			case "DOOR":
				object = Door.loadFromScanner(s);
				break;
			}
			grid[objectX][objectY] = object;
		}
	}
	/**
	 * returns a list of all the ID's of the players in the room
	 * @return
	 */
	public List<Integer> findPlayersInRoom() {
		List<Integer> playerIDList = new ArrayList<Integer>();
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < length; x++) {
				if (grid[x][y] != null) {
					if (grid[x][y] instanceof HumanPlayer) {
						HumanPlayer current = (HumanPlayer) grid[x][y];
						playerIDList.add(current.getId());
					}
				}
			}
		}
		return playerIDList;
	}
	/**
	 * attempts to find the player with the given ID in the room grid
	 * @param id
	 * @return a HumanPlayer object if the player is found
	 * returns null if no player is found
	 */
	public HumanPlayer findPlayer(int id) {
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < length; x++) {
				if (grid[x][y] != null) {
					if (grid[x][y] instanceof HumanPlayer) {
						HumanPlayer current = (HumanPlayer) grid[x][y];
						if (current.getId() == id) {
							return current;
						}
					}
				}
			}
		}
		return null;
	}
	/**
	 * returns the height of the room
	 * @return
	 */
	public int getHeight() {
		return height;
	}
	/**
	 * returns the length of the room
	 * @return
	 */
	public int getWidth() {
		return length;
	}
	/**
	 * returns the room grid
	 * @return
	 */
	public WorldObject[][] getGrid() {
		return grid.clone();
	}
}
